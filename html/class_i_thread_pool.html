<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>RR Thread Pool: IThreadPool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RR Thread Pool
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_i_thread_pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IThreadPool Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__threading-high.html">High level concurrency</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>General purpose thread pool for inter-thread communication.  
 <a href="class_i_thread_pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_thread_pool_8h_source.html">ThreadPool.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6dc963b8cd191a999df00c1a578ae5b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dc963b8cd191a999df00c1a578ae5b2"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_thread_pool.html#a6dc963b8cd191a999df00c1a578ae5b2">~IThreadPool</a> ()</td></tr>
<tr class="memdesc:a6dc963b8cd191a999df00c1a578ae5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a6dc963b8cd191a999df00c1a578ae5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a657c7019998bdcbc21d23fadde06f"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_thread_pool.html#a49a657c7019998bdcbc21d23fadde06f">push</a> (Task task)=0</td></tr>
<tr class="memdesc:a49a657c7019998bdcbc21d23fadde06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes one task into the pool.  <a href="#a49a657c7019998bdcbc21d23fadde06f">More...</a><br/></td></tr>
<tr class="separator:a49a657c7019998bdcbc21d23fadde06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d41f12d0baf13de3f08648a000bafcd"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_thread_pool.html#a1d41f12d0baf13de3f08648a000bafcd">pop</a> (Task &amp;task, bool blocking)=0</td></tr>
<tr class="memdesc:a1d41f12d0baf13de3f08648a000bafcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops one executed/cancelled task from the pool.  <a href="#a1d41f12d0baf13de3f08648a000bafcd">More...</a><br/></td></tr>
<tr class="separator:a1d41f12d0baf13de3f08648a000bafcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2fd4dc06187f620865ea7baa961a11"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_thread_pool.html#a9a2fd4dc06187f620865ea7baa961a11">cancel</a> ()=0</td></tr>
<tr class="memdesc:a9a2fd4dc06187f620865ea7baa961a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel the pool functionality indefinitely releasing any thread.  <a href="#a9a2fd4dc06187f620865ea7baa961a11">More...</a><br/></td></tr>
<tr class="separator:a9a2fd4dc06187f620865ea7baa961a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9344e9851ca43e748c0c86cc64dc2dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_thread_pool.html#ac9344e9851ca43e748c0c86cc64dc2dd">join</a> ()=0</td></tr>
<tr class="memdesc:ac9344e9851ca43e748c0c86cc64dc2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel and wait for the termination of pool's threads.  <a href="#ac9344e9851ca43e748c0c86cc64dc2dd">More...</a><br/></td></tr>
<tr class="separator:ac9344e9851ca43e748c0c86cc64dc2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecaf8eb2512e34950e6543d8bcc91bd"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3ecaf8eb2512e34950e6543d8bcc91bd"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_i_thread_pool.html#a3ecaf8eb2512e34950e6543d8bcc91bd">popT</a> (std::shared_ptr&lt; Derived &gt; &amp;task, bool blocking)</td></tr>
<tr class="memdesc:a3ecaf8eb2512e34950e6543d8bcc91bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient template method to pop executed tasks.  <a href="#a3ecaf8eb2512e34950e6543d8bcc91bd">More...</a><br/></td></tr>
<tr class="separator:a3ecaf8eb2512e34950e6543d8bcc91bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aae218c37d60b5255438a2b1adea57201"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_i_thread_pool.html">IThreadPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_thread_pool.html#aae218c37d60b5255438a2b1adea57201">create</a> (std::size_t num_threads, std::size_t task_capacity=std::numeric_limits&lt; std::size_t &gt;::max())</td></tr>
<tr class="memdesc:aae218c37d60b5255438a2b1adea57201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create a thread pool implemented for the current platform.  <a href="#aae218c37d60b5255438a2b1adea57201">More...</a><br/></td></tr>
<tr class="separator:aae218c37d60b5255438a2b1adea57201"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>General purpose thread pool for inter-thread communication. </p>
<p>The class is defined as a pure abstract class with a factory method (see <a class="el" href="class_i_message_queue.html#ad10a85019d09acab0cbad1ee3eb1b141">IMessageQueue::create</a>) to build platform-specific implementations of the queue while maintaining a platform-agnostic interface.</p>
<p>The class is 100% thread safe. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9a2fd4dc06187f620865ea7baa961a11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IThreadPool::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel the pool functionality indefinitely releasing any thread. </p>
<p>Also cancel any task that have not yet executed. Those task are queued on the list of executed one and can be popped (see method <a class="el" href="class_i_thread_pool.html#a1d41f12d0baf13de3f08648a000bafcd">pop</a>).</p>
<p>The cancelled status is not reversible and is meant mainly as an action to be performed before the pool destruction.</p>
<dl class="section warning"><dt>Warning</dt><dd>Doesn't wait for the peer threads to be released, just broadcast a signal to them. </dd></dl>

</div>
</div>
<a class="anchor" id="aae218c37d60b5255438a2b1adea57201"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_i_thread_pool.html">IThreadPool</a>* IThreadPool::create </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>task_capacity</em> = <code>std::numeric_limits&lt;&#160;std::size_t&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create a thread pool implemented for the current platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>The number of threads the pool should use concurrently.</td></tr>
    <tr><td class="paramname">task_capacity</td><td>Maximum number of tasks that can be queued at the same time before their execution. By default this limit is relaxed as much as possible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created thread pool. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9344e9851ca43e748c0c86cc64dc2dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IThreadPool::join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel and wait for the termination of pool's threads. </p>
<p>This method calls the method <a class="el" href="class_i_thread_pool.html#a9a2fd4dc06187f620865ea7baa961a11">cancel</a> and than waits indefinitely for the pool's threads.</p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The behaviour of this method if called during the task execution is undefined. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1d41f12d0baf13de3f08648a000bafcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t IThreadPool::pop </td>
          <td>(</td>
          <td class="paramtype">Task &amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pops one executed/cancelled task from the pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">task</td><td>Smart pointer that will be reset with the popped task in case of success.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blocking</td><td>If set to <em>true</em> the method blocks the current thread indefinitely until a new task have been executed or the pool have been cancelled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, the number of tasks already completed not yet popped before the extraction, that is at least <em>one</em>.</li>
<li>On failure, <em>zero</em> (parameter task is not touched in that case).</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The pool have not been cancelled. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a3ecaf8eb2512e34950e6543d8bcc91bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t IThreadPool::popT </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenient template method to pop executed tasks. </p>
<p>Since by design the user should derive messages from the class <a class="el" href="class_i_task.html">ITask</a> this template take care to dynamic cast shared pointers to the user defined derived class.</p>
<p>This method is meant to be used when the user uses the pool with one single derived class and hence don't need to manually dynamic cast every popped message from the generic <em><a class="el" href="class_i_task.html" title="Abstract class to be implemented to describe a task that need to be executed. ">ITask</a></em>.</p>

</div>
</div>
<a class="anchor" id="a49a657c7019998bdcbc21d23fadde06f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t IThreadPool::push </td>
          <td>(</td>
          <td class="paramtype">Task&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes one task into the pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, the number of tasks pending to be executed after the insertion, that is at least <em>one</em>.</li>
<li>On failure, <em>zero</em>. This may happen if the maximum allowed capacity for pending tasks have been reached.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The parameter task is not null.</li>
<li>The pool have not been cancelled. </li>
</ul>
</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_thread_pool_8h_source.html">ThreadPool.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 25 2015 06:23:47 for RR Thread Pool by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
