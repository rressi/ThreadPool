<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>RR Thread Pool: IMessageQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RR Thread Pool
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_i_message_queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IMessageQueue Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__threading-high.html">High level concurrency</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>General purpose message queue for inter-thread communication.  
 <a href="class_i_message_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_message_queue_8h_source.html">MessageQueue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea393cccd1ab97efea78bdea9c87dd9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea393cccd1ab97efea78bdea9c87dd9e"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_message_queue.html#aea393cccd1ab97efea78bdea9c87dd9e">~IMessageQueue</a> ()</td></tr>
<tr class="memdesc:aea393cccd1ab97efea78bdea9c87dd9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:aea393cccd1ab97efea78bdea9c87dd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632dcc59198319bbae4909a5b252481a"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_message_queue.html#a632dcc59198319bbae4909a5b252481a">push</a> (<a class="el" href="group__threading-high.html#ga4166e061b76018aa8ee54cd7112368b5">Message</a> message)=0</td></tr>
<tr class="memdesc:a632dcc59198319bbae4909a5b252481a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes one message into the queue.  <a href="#a632dcc59198319bbae4909a5b252481a">More...</a><br/></td></tr>
<tr class="separator:a632dcc59198319bbae4909a5b252481a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad715f86c6435e4d5f4a160962d34c5b"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_message_queue.html#aad715f86c6435e4d5f4a160962d34c5b">pop</a> (<a class="el" href="group__threading-high.html#ga4166e061b76018aa8ee54cd7112368b5">Message</a> &amp;message, bool blocking)=0</td></tr>
<tr class="memdesc:aad715f86c6435e4d5f4a160962d34c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops one message from the queue.  <a href="#aad715f86c6435e4d5f4a160962d34c5b">More...</a><br/></td></tr>
<tr class="separator:aad715f86c6435e4d5f4a160962d34c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058ae21ce1b86ec69e160f518dac5faf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_message_queue.html#a058ae21ce1b86ec69e160f518dac5faf">cancel</a> ()=0</td></tr>
<tr class="memdesc:a058ae21ce1b86ec69e160f518dac5faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel the queue functionality indefinitely releasing any blocked thread.  <a href="#a058ae21ce1b86ec69e160f518dac5faf">More...</a><br/></td></tr>
<tr class="separator:a058ae21ce1b86ec69e160f518dac5faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81b85bad0c042c4185da764a57a27f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac81b85bad0c042c4185da764a57a27f1"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_message_queue.html#ac81b85bad0c042c4185da764a57a27f1">is_cancelled</a> () const =0</td></tr>
<tr class="memdesc:ac81b85bad0c042c4185da764a57a27f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>true</em> if the queue have been cancelled. <br/></td></tr>
<tr class="separator:ac81b85bad0c042c4185da764a57a27f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac032e4d3c1e4eee2772896dc6d015fa8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac032e4d3c1e4eee2772896dc6d015fa8"></a>
virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_message_queue.html#ac032e4d3c1e4eee2772896dc6d015fa8">size</a> () const =0</td></tr>
<tr class="memdesc:ac032e4d3c1e4eee2772896dc6d015fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of messages contained inside the queue. <br/></td></tr>
<tr class="separator:ac032e4d3c1e4eee2772896dc6d015fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f3b992c8ac1d5318e095fc49d9f9a0"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a09f3b992c8ac1d5318e095fc49d9f9a0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_i_message_queue.html#a09f3b992c8ac1d5318e095fc49d9f9a0">popT</a> (std::shared_ptr&lt; Derived &gt; &amp;message, bool blocking)</td></tr>
<tr class="memdesc:a09f3b992c8ac1d5318e095fc49d9f9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient template method to pop messages.  <a href="#a09f3b992c8ac1d5318e095fc49d9f9a0">More...</a><br/></td></tr>
<tr class="separator:a09f3b992c8ac1d5318e095fc49d9f9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad10a85019d09acab0cbad1ee3eb1b141"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_i_message_queue.html">IMessageQueue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_message_queue.html#ad10a85019d09acab0cbad1ee3eb1b141">create</a> (std::size_t max_capacity=std::numeric_limits&lt; std::size_t &gt;::max())</td></tr>
<tr class="memdesc:ad10a85019d09acab0cbad1ee3eb1b141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create a message queue implemented for the current platform.  <a href="#ad10a85019d09acab0cbad1ee3eb1b141">More...</a><br/></td></tr>
<tr class="separator:ad10a85019d09acab0cbad1ee3eb1b141"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>General purpose message queue for inter-thread communication. </p>
<p>This class uses run-time polymorphism to allow message-driven communication and synchronization between two or more threads.</p>
<p>The class is defined as a pure abstract class with a factory method (see <a class="el" href="class_i_message_queue.html#ad10a85019d09acab0cbad1ee3eb1b141">IMessageQueue::create</a>) to build platform-specific implementations of the queue while maintaining a platform-agnostic interface.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Only one method of this class can (optionally) block the calling thread: <a class="el" href="class_i_message_queue.html#aad715f86c6435e4d5f4a160962d34c5b">IMessageQueue::pop</a>.</li>
<li>This class is 100% thread safe. </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a058ae21ce1b86ec69e160f518dac5faf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IMessageQueue::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel the queue functionality indefinitely releasing any blocked thread. </p>
<p>The cancelled status is not reversible and is meant mainly as an action to be performed before the queue destruction.</p>
<dl class="section note"><dt>Note</dt><dd>Doesn't wait for the peer threads to be released, just broadcast a signal to them. </dd></dl>

</div>
</div>
<a class="anchor" id="ad10a85019d09acab0cbad1ee3eb1b141"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_i_message_queue.html">IMessageQueue</a>* IMessageQueue::create </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_capacity</em> = <code>std::numeric_limits&lt;&#160;std::size_t&#160;&gt;::max()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create a message queue implemented for the current platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_capacity</td><td>Maximum number of messages that can be queued at the same time. By default this limit is relaxed as much as possible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created message queue. </dd></dl>

</div>
</div>
<a class="anchor" id="aad715f86c6435e4d5f4a160962d34c5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t IMessageQueue::pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading-high.html#ga4166e061b76018aa8ee54cd7112368b5">Message</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pops one message from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">message</td><td>Smart pointer that will be reset with the popped message in case of success.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blocking</td><td>If set to <em>true</em> the method blocks the current thread indefinitely until a new message is pushed into the queue by another thread or until the queue is not cancelled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, the number of messages contained by the queue before the extraction, that is at least <em>one</em>.</li>
<li>On failure, <em>zero</em> (parameter message is not touched in that case).</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The queue have not been cancelled. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a09f3b992c8ac1d5318e095fc49d9f9a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t IMessageQueue::popT </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenient template method to pop messages. </p>
<p>Since by design the user should derive messages from the class <a class="el" href="class_i_message.html">IMessage</a> this template take care to dynamic cast shared pointers to the user defined derived class.</p>
<p>This method is meant to be used when the user uses the queue with one single derived class and hence don't need to manually dynamic cast every popped message from the generic <em><a class="el" href="class_i_message.html" title="Abstract class to be implemented to describe a Message that need to be executed. ">IMessage</a></em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">message</td><td>Smart pointer that will be reset with the popped message in case of success.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blocking</td><td>If set to <em>true</em> the method blocks the current thread indefinitely until a new message is pushed into the queue by another thread or until the queue is not cancelled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, the number of messages contained by the queue before the extraction, that is at least <em>one</em>.</li>
<li>On failure, <em>zero</em> (parameter message is not touched in that case).</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The queue have not been cancelled. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a632dcc59198319bbae4909a5b252481a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t IMessageQueue::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading-high.html#ga4166e061b76018aa8ee54cd7112368b5">Message</a>&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes one message into the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, the number of messages contained by the queue after the insertion, that is at least <em>one</em>.</li>
<li>On failure, <em>zero</em>. This may happen if the maximum allowed capacity for the queue have been reached.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The parameter message is not null.</li>
<li>The queue have not been cancelled. </li>
</ul>
</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_message_queue_8h_source.html">MessageQueue.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 25 2015 06:23:47 for RR Thread Pool by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
